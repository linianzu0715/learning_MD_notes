## 目录

[toc]



## 数据库三范式

1. 第一范式(确保每列保持原子性)

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

2. 第二范式(确保表中的每列都和主键相关)

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

3. 第三范式(确保每列都和主键列直接相关,而不是间接相关)

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。



## 数据库隔离级别

多个事务读可能会道理以下问题
脏读：事务B读取事务A还没有提交的数据
不可重复读：一行被检索两次，并且该行中的值在不同的读取之间不同时
幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时 这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回的集合不一样



## MYSQL存储引擎区别

| 引擎   | 特性                                                         |
| ------ | ------------------------------------------------------------ |
| MYISAM | 不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描 |
| INNODB | 支持外键，行锁，查表总行数时，全表扫描                       |



## 索引

### B+索引和hash索引

| 索引 | 区别                                                |
| ---- | --------------------------------------------------- |
| Hash | hash索引，等值查询效率高，不能排序,不能进行范围查询 |
| B+   | 数据有序,范围查询                                   |



### 聚集索引和非聚集索引

| 索引       | 区别                                           |
| ---------- | ---------------------------------------------- |
| 聚集索引   | 数据按索引顺序存储，中子结点存储真实的物理数据 |
| 非聚集索引 | 存储指向真正数据行的指针                       |



### 索引的优缺点，什么时候使用索引，什么时候不能使用索引

索引最大的好处是提高查询速度， 缺点是更新数据时效率低，因为要同时更新索引 

对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。



### 索引分类，索引失效条件

| 索引类型 | 概念                                                         |
| -------- | ------------------------------------------------------------ |
| 普通索引 | 最基本的索引，没有任何限制                                   |
| 唯一索引 | 与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。 |
| 主键索引 | 它是一种特殊的唯一索引，不允许有空值。                       |
| 全文索引 | 针对较大的数据，生成全文索引很耗时好空间。                   |
| 组合索引 | 为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则    |



### 索引的底层实现（B+树，为何不采用红黑树，B树）重点

| 树       | 区别                                                         |
| -------- | ------------------------------------------------------------ |
| 红黑树   | 增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间 |
| B树/B-树 | B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。 |
| B+树     | B+树相比较于另外两种树,显得更矮更宽，查询层次更浅            |

**红黑树**：

红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在[二叉查找树](https://baike.baidu.com/item/二叉查找树/7077965)强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

1. 节点是红色或黑色。
2. 根节点是黑色
3. 所有叶子都是黑色。（叶子是NUIL节点）
4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作（比如插入、删除和查找某个值）的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。是性质4导致路径上不能有两个连续的红色节点确保了这个结果。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。因为红黑树是一种特化的[二叉查找树](https://baike.baidu.com/item/二叉查找树/7077965)，所以红黑树上的只读操行与普通二叉查找树相同。

**B树**：

在B-树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针所指的结点继续查找，直至找到，或指针Pi为空时查找失败。



## Sql的优化

**1.sql尽量使用索引,而且查询要走索引**

**2.对sql语句优化**

子查询变成left join
limit 分布优化，先利用ID定位，再分页
or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）
不必要的排序
where代替having,having 检索完所有记录，才进行过滤
避免嵌套查询
对多个字段进行等值查询时，联合索引



## 事务

### 事务四大特性

原子性，要么执行，要么不执行   

隔离性，所有操作全部执行完以前其它会话不能看到过程 

一致性，事务前后，数据总额一致 

持久性，一旦事务提交，对数据的改变就是永久的



## 数据库的主从复制

### 主从复制的用途：

1. 实时灾备，用于故障切换
2. 读写分离，提供查询服务
3. 备份，避免影响业务

### 主从部署必要条件：

1. 主库开启binlog日志（设置log-bin参数）
2. 主从server-id不同
3. 从库服务器能连通主库

### 主从复制的形式

1. 一主一从
2. 主主复制
3. 一主多从
4. 多主一从
5. 联级复制

![数据库-主从复制](/Users/linianzu/Documents/Learning/md/大数据开发/pic/数据库-主从复制.png)

## JOIN

1. INNER JOIN 产生的结果是AB的交集
2. LEFT [OUTER] JOIN 产生表A的完全集，而B表中匹配的项则有值，没有匹配的则以null值取代。
3. RIGHT [OUTER] JOIN 产生表B的完全集，而A表中匹配的则有值，没有匹配的则以null值取代。
4. FULL [OUTER] JOIN 产生A和B的并集。对于没有匹配的记录，则会以null做为值。
5. CROSS JOIN 把表A和表B的数据进行一个N*M的组合，即笛卡尔积。如本例会产生4*4=16条记录，在开发过程中我们肯定是要过滤数据，所以这种很少用。



#### 16.varchar和char的使用场景

| 类型    | 使用场景         |
| ------- | ---------------- |
| varchar | 字符长度经常变的 |
| char    | 用字符长度固定的 |



#### 17.数据库连接池的作用

维护一定数量的连接，减少创建连接的时间 

更快的响应时间 

统一的管理



## 关系型数据库和非关系型数据库区别

**关系型数据库**

优点

1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；

2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；
3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
4、支持SQL，可用于复杂的查询。
5、支持事务

缺点
1、为了维护一致性所付出的巨大代价就是其读写性能比较差；
2、固定的表结构；
3、不支持高并发读写需求；
4、不支持海量数据的高效率读写

**非关系型数据库**

1、使用键值对存储数据； 

2、分布式； 优点 无需经过sql层的解析，读写性能很高 基于键值对，数据没有耦合性，容易扩展 存储数据的格式：nosql的存储格式是key,value形式 缺点 不提供sql支持



#### 22.数据库中join的left join , inner join, cross join



#### 23.有哪些锁,select时怎么加排它锁

| 锁     | 概念                                                  |
| ------ | ----------------------------------------------------- |
| 乐观锁 | 自己实现，通过版本号                                  |
| 悲观锁 | 共享锁，多个事务，只能读不能写，加 lock in share mode |
| 排它锁 | 一个事务，只能写，for update                          |
| 行锁   | 作用于数据行                                          |
| 表锁   | 作于用表                                              |

**悲观锁：**

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。

**乐观锁：**

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。

**共享锁：**

共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

**排他锁：**

用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突）

**版本号机制：**

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。


**CAS算法：**

即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

需要读写的内存值 V
进行比较的值 A
拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。



#### 最左匹配原则

最左匹配原则是针对索引的
举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，
这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，
查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，
按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了
