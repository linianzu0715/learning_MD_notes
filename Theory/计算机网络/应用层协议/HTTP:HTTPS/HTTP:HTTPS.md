# HTTP

[toc]



## 公钥和私钥

公钥和私钥就是俗称的不对称加密方式。

##### 公钥和私钥的性质

1. 公钥是可以通过公开途径获取的，私钥是自己保有的。
2. 公钥用来加密/验章，私钥用来解密/签章。
3. 公钥加密的内容只能用私钥来解密
4. 私钥签章的内容只能由公钥来验章

##### 使用场景

**场景1**：A需要向B发送一个信息，要求A发送的信息必须保密，不能被其他人看到。

**方法1**：A用B的公钥对信息进行加密，然后将信息传输。B用自己的私钥对接受的信息进行解密。这样保证只有B能够看到A发送的消息的内容。因为只有B拥有自己的私钥

**场景2**：A需要向B发送一个信息，要求保证这个信息是A发送的，不能被别人冒充。

**方法2**：A用自己的私钥对信息进行签章，然后将信息进行传输。B将接受到的信息用A的公钥进行验章。因为只用A拥有自己的私钥，因此能够保证消息一定是A发出的。

##### 数字证书

用户设置私钥，用它来进行解密/验章。用户公开公钥给一组用户共享，获得公钥的用户用它来加密/验章。

场景1:发送保密文件。保证发送的消息只会被接收方获取，其余人即使截获信息也无法解密信息的具体内容。

场景2:数字签名。保证信息由签名者发送，签名者无法否认。保证信息发送之后没有被修改，保证信息的真实性。



## URL组成结构

以下面这个URL为例，介绍下普通URL的各部分组成：

http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name

1. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2. 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。
3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分。http协议的默认端口是80，https协议的默认端口是443。
4. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。
5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名
6. 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。



#### HTTP方法

|  方法   | 说明                                                         |
| :-----: | :----------------------------------------------------------- |
| OPTIONS | 返回服务器针对特定资源所支持的HTTP请求方法                   |
|  HEAD   | 向服务器索要和GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息 |
|   GET   | 向特定的资源发出请求                                         |
|  POST   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建或者已有资源的修改。 |
|   PUT   | 向指定资源位置上传新的内容                                   |
| DELETE  | 请求服务器删除REQUEST-URL所标识的资源                        |
|  TRACE  | 回显服务器收到的请求，只要用于测试或者诊断                   |
| CONNECT | HTTP/1.1协议中预留给能够将连接改造为管道方式的代理服务器。   |



## HTTP请求报文

一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

![](https://github.com/linianzu0715/learning_MD_notes/blob/main/Picture/请求报文.png?raw=true)

＜request-line＞

＜headers＞

＜blank line＞

[＜request-body＞]

**1.请求行**

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。详情参考请求方法。



**2.请求头部**

请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

- Accpet:告诉服务端,客户端接收什么类型的响应
- Referer: 表示这是请求是从哪个URL进来的,比如想在网上购物,但是不知道选择哪家电商平台,你就去问度娘,说哪家电商的东西便宜啊,然后一堆东西弹出在你面前,第一给就是某宝,当你从这里进入某宝的时候,这个请求报文的Referer就是

- Cache-Control: 对缓存进行控制,如一个请求希望响应的内容在客户端缓存一年,或不被缓可以通过这个报文头设置

- Accept-Encoding: 这个属性是用来告诉服务器能接受什么编码格式,包括字符编码,压缩形式(一般都是压缩形式) 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)

- Host: 指定要请求的资源所在的主机和端口
- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称



**3.空行**

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。



**4.请求数据**

请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。



## HTTP响应报文

![](http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902557.jpg)



同样的，HTTP响应报文也由三部分组成：响应行、响应头、响应体



**1.响应行**

响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK

其中协议版本HTTP/1.1或者HTTP/1.0，200就是它的状态码，OK则为它的描述。

HTTP状态码分类：

| 分类 | 分类描述                                       |
| :--: | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

常见的HTTP状态码：

| 状态码 |               解释                |
| :----: | :-------------------------------: |
|  200   |             请求成功              |
|  301   | 资源（网页等）被永久转移到其它URL |
|  404   |    请求的资源（网页等）不存在     |
|  500   |          内部服务器错误           |



**2.响应头**

响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。

设置HTTP响应头往往和状态码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401(Unauthorized)状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。

常见的响应头字段含义：

1. Allow：服务器支持哪些请求方法(如GET、POST等)。
2. Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。[Java](https://www.2cto.com/kf/ware/Java/)的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE4、IE5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept- Encoding”))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。
3. Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。
4. Content- Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。
5. Date：当前的GMT时间，例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
6. Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。
7. Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置。
8. Location：这个头配合302状态码使用，用于重定向接收者到一个新URI地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。
9. Refresh：告诉浏览器隔多久刷新一次，以秒计。
10. Server：服务器通过这个头告诉浏览器服务器的类型。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。Servlet一般不设置这个值，而是由Web服务器自己设置。
11. Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。
12. Transfer-Encoding：告诉浏览器数据的传送格式。
13. WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息?在包含401(Unauthorized)状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=\”executives\”“)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问。

注：设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。

setDateHeader方法和setIntHeadr方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。

HttpServletResponse还提供了许多设置

setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。

setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。

addCookie：设置一个Cookie(Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头)。

**3.响应体**

响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。



## HTTP的长连接和短连接

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议.

**短连接**:浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

**长连接**:当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

**TCP短连接:** client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在client/server间传递一次读写操作

**TCP长连接:** client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。



## 关于HTTP请求GET和POST的区别

1.GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&连接;例如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。

 POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据

 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变

 

2.传输数据的大小：

  首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：

  GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。

  因此对于GET提交时，传输数据就会受到URL长度的限制。

  POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。

 

3.安全性：

  POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，



## HTTP和HTTPS

超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

**一、HTTP和HTTPS的基本概念**

* HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
* HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。



**二、HTTP有什么缺点？**

* 通信使用明文，内容有可能被窃听（重要密码泄露）
* 不验证通信方身份，有可能遭遇伪装（跨站点请求伪装）
* 无法证明报文的完整性，有可能已经遭到篡改（运营商劫持）



**三、HTTP与HTTPS有什么区别？**

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS和HTTP的区别主要如下：

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

| HTTP | HTTP |
| :--: | :--: |
| TCP  | SSL  |
|  IP  | TCP  |
|      |  IP  |

**四、SSL**

SSL是"Secure Sockets Layer"的缩写，中文叫做”安全套接层“。原先互联网上使用的HTTP协议是明文的，存在安全性风险。SSL解决这个问题。

SSL协议位于TCP/IP协议和各种应用层协议之间，为数据通信提供安全支持。SSL协议可以分成两层：

* SSL记录协议（SSL RECORD PROTOCOL):它简历在可靠的传输协议（如TCP）之上，为高层协议提供数据封装，压缩，加密等基本的支持
* SSL握手协议（SSL HANDSHAKE PROTOCOL):它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证，协商加密算法，交换加密密钥等。



**五、对称密钥加密和非对称密钥加密**

对称密钥加密，又称之为私钥加密，即信息的发送放和接收方用同一个密钥去加密和解密数据，优点是加密/解密的速度快，适合于对大数据量进行加密，但是密钥管理复杂。

非对称密钥加密，又称为公钥加密，它是要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个又用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接受者用私用密钥去解密。从功能角度看，非对称加密比对称加密强大，但是加密和解密的速度慢。



**六、HTTPS工作原理**

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
3. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5. Web服务器利用自己的私钥解密出会话密钥。
6. Web服务器利用会话密钥加密与客户端之间的通信。



#### HTTP和TCP的关联

1. TCP是底层通讯协议，定义的是数据传输和连接方式的规范
2. HTTP是应用层协议，定义的是传输数据的内容的规范
3. HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP   